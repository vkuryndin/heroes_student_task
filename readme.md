# Heroes Student Task

# Description

Этот репозиторий содержит мою реализацию требуемых алгоритмов для проекта **Heroes** (модуль `heroes_task`).  
Игра загружает данный модуль как JAR-файл и использует его для:

- генерации пресета армии противника,
- симуляции пошагового боя,
- отбора целей, доступных для атаки (для ближнего боя),
- поиска кратчайшего пути на игровом поле между юнитами.

---

## Структура проекта
    src/
     programs/
      GeneratePresetImpl.java
      SimulateBattleImpl.java
      SuitableForAttackUnitsFinderImpl.java
      UnitTargetPathFinderImpl.java

Собранный артефакт (JAR) также добавлен в репозиторий — его можно подложить в папку игры `heroes/jars` под именем `obf.jar`.

## Реализованные алгоритмы

### 1) Генерация армии противника — `GeneratePresetImpl.generate(...)`

**Цель:** сформировать армию компьютера при ограничениях:
- суммарная стоимость ≤ `maxPoints`,
- не более 11 юнитов каждого типа,
- максимальная эффективность: в первую очередь по **атака/стоимость**, во вторую — по **здоровье/стоимость**.

**Подход:**
- **Pre-sorted greedy** (жадный алгоритм с предварительной сортировкой и фильтрацией по бюджету), без мульти-стартов.
- Сначала шаблоны группируются по `unitType` (поддерживает несколько шаблонов на тип).
- Далее строится упорядоченная приоритетная структура кандидатов (`TreeSet`) по **строгому приоритету задания**:
  - основное: `baseAttack / cost`,
  - вторичное: `health / cost`,
  - далее — детерминированные тай-брейки (например, по `baseAttack`, `health`, `cost`, `unitType`, плюс внутренний `id`, чтобы порядок был полным и стабильным).
- На каждом шаге выбирается **текущий лучший** шаблон из `TreeSet`:
  - шаблоны, которые **не помещаются** в текущий остаток бюджета, удаляются из множества **монотонно** (через отдельный список, отсортированный по `cost` по убыванию — каждый шаблон удаляется не более одного раза);
  - если по выбранному типу достигнут лимит 11, все шаблоны этого типа удаляются из множества кандидатов.
- Координаты назначаются безопасно внутри сетки **3×21** (`x ∈ [0..2]`, `y ∈ [0..20]`) и проверяются на занятость за **O(1)** через boolean-матрицу.

**Сложность:**
Обозначим:
- `T` — число шаблонов (обычно близко к числу типов, сейчас ~4),
- `n` — число добавленных юнитов в итоговой армии (ограничено лимитами и площадью 3×21),
- `m` — число типов юнитов.

Тогда:
- построение/сортировка кандидатов в `TreeSet` → `O(T log T)`,
- монотонное удаление “слишком дорогих” шаблонов (каждый удаляется максимум один раз) → суммарно `O(T log T)`,
- выбор лучшего кандидата на каждом добавлении юнита → `O(log T)` на шаг, всего `O(n log T)`.

Итого: **`O(T log T + n log T)`**, что **быстрее**, чем `O(m·n)` при типичных входных данных и формально лучше пересканирования всех типов на каждом шаге.

**Улучшение относительно базовой реализации:**
В базовой реализации обычно встречается:
- пересканирование всех типов/шаблонов на каждом шаге → `O(m·n)`,
- и/или проверка занятости клетки через `stream().anyMatch(...)` по растущему списку уже размещённых юнитов, что может давать суммарно **`O(n²)`**.

В текущей реализации:
- выбор кандидата ускорен за счёт `TreeSet` + монотонной фильтрации по бюджету (без полного пересканирования типов на каждом шаге),
- проверка занятости клетки выполняется через boolean-матрицу фиксированного размера (3×21), поэтому **O(1)**, а fallback-сканирование — константа (≤ 63 клетки).

---

### 2) Симуляция боя — `SimulateBattleImpl.simulate(...)`

**Цель:** корректно смоделировать бой по правилам:
- бой идёт по раундам,
- внутри очереди каждой стороны юниты идут по убыванию `baseAttack`, при этом ходы чередуются между армией игрока и компьютера,
- ходы чередуются между армией игрока и компьютера,
- если юнит погиб до своего хода в текущем раунде — его нужно исключить сразу и пересчитать очереди,
- после каждой атаки вызвать `printBattleLog.printBattleLog(attacker, target)` (если `printBattleLog` не был заинжекчен (null), используется безопасный fallback-логгер в stdout, чтобы избежать `NullPointerException`),
- бой заканчивается только, когда в одной из армий не остаётся живых юнитов, способных сделать ход.

**Подход:**
- Используется множество `actedThisRound` (identity-based), чтобы каждый живой юнит ходил не более одного раза за раунд.
- На начало каждого раунда строятся две очереди ходов `PriorityQueue<Unit>` (max-heap по `baseAttack`):
  - в очередь попадают только живые юниты, которые ещё не ходили в текущем раунде.
- Ходы чередуются: сначала игрок (если есть юнит), затем компьютер (если есть юнит).
  Если у одной стороны очередь опустела — другая продолжает ходить.
- После каждого вызова `unit.getProgram().attack()` всегда вызывается `printBattleLog.printBattleLog(attacker, target)`.
  Если `attack()` вернул атакующего юнита (self), это трактуется как `null` (нет цели).
- Если цель умерла **до своего хода** в текущем раунде, пересобираются **обе очереди** ходов (игрока и компьютера), чтобы корректно восстановить порядок оставшихся ходов в раунде.
- После каждого раунда печатается:
  - пустая строка,
  - `Round N is over!`,
  - количество живых юнитов у каждой армии,
  - пустая строка.

- **Завершение боя:**
  Бой завершается, если одна из армий осталась без живых юнитов, либо если за полный раунд одна из сторон
  не смогла выполнить ни одной осмысленной атаки (все `attack()` возвращали `null` / self → `null`).
  Это соответствует формулировке задания про “юнитов, способных сделать ход” и закрывает сценарии тупика.


**Сложность:**
Пусть `N` — общее число живых юнитов в обеих армиях в начале раунда.
- Построение очереди ходов для одной армии: **O(k log k)**, где `k` — число живых юнитов этой армии, ещё не ходивших в раунде.
- Каждый `poll()` из `PriorityQueue`: **O(log k)** на ход.
- При “важной” смерти (цель умерла до своего хода в текущем раунде) в текущей реализации
  пересобираются **обе очереди** ходов, что стоит **O(N log N)** на одну пересборку.

Итого за раунд: базово **O(N log N)** + стоимость пересборок.
Если обозначить `D` — число пересборок очередей в раунде, то время: **O((N + D·N) log N)**, в худшем случае **O(N² log N)**,
но на типичных размерах армий работает быстро.

---

### 3) Отбор целей для атаки — `SuitableForAttackUnitsFinderImpl.getSuitableUnits(...)`

**Цель:** вернуть только те вражеские юниты, которые доступны для атаки (не “прикрыты” соседней колонкой):
- при атаке правой армии (армия игрока) цель недоступна, если закрыта справа (в соседней клетке/колонке по y стоит живой юнит той же армии),
- при атаке левой армии (армия компьютера) — аналогично, только блокировка слева.

Вход `unitsByRow` содержит 3 колонки (фиксировано), в каждой — список юнитов по y.

Важно: блокировка учитывает только соседнюю колонку (immediate neighbor), а не “любого юнита впереди”.

**Подход:**
- Для фронтальной и средней колонок строятся `BitSet` маски занятых y (только живые юниты).
- Юнит:
    - в передней колонке → всегда доступен,
    - в средней → доступен, если в передней нет живого с тем же y,
    - в задней → доступен, если в средней нет живого с тем же y.


**Сложность:**
Пусть `N` — число юнитов в трёх списках:
- построение BitSet + фильтрация — **O(N)**.
  Так как колонок всегда 3, фактически это линейная сложность по числу юнитов.
- 
- Если `unitsByRow == null` или список не содержит ровно 3 колонки, либо подходящих целей нет — возвращается пустой список и печатается `Unit can not find target for attack!`.


---

### 4) Поиск кратчайшего пути — `UnitTargetPathFinderImpl.getTargetPath(...)`

**Цель:** найти кратчайший путь от атакующего к цели на сетке:
- `WIDTH = 27`, `HEIGHT = 21`,
- движение разрешено в 8 направлений (включая диагонали),
- живые юниты (кроме атакующего и цели) считаются препятствиями,
- результат: список `Edge` (координаты пути), включающий старт и цель, либо пустой список, если пути нет.
- Диагональные ходы разрешены без дополнительных проверок “corner-cutting”.

**Подход: двунаправленный BFS (Bidirectional BFS)**
- BFS запускается одновременно от атакующего и от цели.
- Хранятся две матрицы посещений и два массива предков (`prevS` и `prevT`) для восстановления пути.
- Поиск останавливается при встрече фронтов.
- Фиксированный порядок направлений делает путь детерминированным (удобно для стабильного поведения и тестов).

**Сложность:**
На поле `V = WIDTH · HEIGHT` клеток.
- Каждая клетка посещается максимум по одному разу с каждой стороны → **O(V)**,
- проверка 8 соседей — константа.
  Итого:
- **O(WIDTH · HEIGHT)** по времени и памяти.

**Ускорение относительно обычного BFS:**
Bidirectional BFS на практике обходит меньше клеток, чем односторонний BFS, так как фронты растут навстречу друг другу.

---

## Сводная таблица сложности алгоритмов

| Компонент | Алгоритм | Сложность | Примечания |
|:---|:---|:---:|:---|
| **GeneratePresetImpl**<br>`generate(...)` | **Pre-sorted greedy**<br>`TreeSet` по приоритету (`atk/cost`, затем `hp/cost`)<br>+ монотонная фильтрация по бюджету | **T:** `O(T log T + n log T)`<br>**M:** `O(T + n)` | Каждый шаблон удаляется из кандидатов максимум 1 раз (монотонно).<br>Координаты: `O(1)` (boolean grid 3×21), fallback-скан — константа (≤ 63). |
| **SimulateBattleImpl**<br>`simulate(...)` | **PriorityQueue** (max-heap)<br>+ Set `actedThisRound`<br>+ Раунды | **T:** `O(N log N)`<br>**M:** `O(N)` | Пересборка **обеих** очередей, если юнит умер до своего хода.<br>Завершение при тупике (нет атак). |
| **SuitableForAttack...**<br>`getSuitableUnits(...)` | **BitSet маски** по Y<br>+ Линейная фильтрация | **T:** `O(N)`<br>**M:** `O(H)`<br>*(H=21)* | Блокировка только **соседней** колонкой (immediate neighbor).<br>3 фиксированных ряда. |
| **UnitTargetPathFinder...**<br>`getTargetPath(...)` | **Bidirectional BFS**<br>Сетка 27×21<br>8 направлений | **T:** `O(W·H)`<br>**M:** `O(W·H)`<br>*(~567)* | Препятствия: все живые (кроме start/target).<br>Порядок направлений фиксирован (детерминизм). |

---
## Как собрать JAR

### Вариант 1. Сборка в IntelliJ IDEA:

1. `File → Project Structure → Artifacts`
2. `+ → JAR → From modules with dependencies`
3. `Build → Build Artifacts → Build`

Далее полученный артефакт можно подложить в папку jars проекта Heroes.

### Вариант 2: Gradle (рекомендуется)

Сборка `obf.jar` одной командой из корня проекта:

    bash ./gradlew clean jar

Результат появится здесь:

    build/libs/obf.jar

Скопируйте `build/libs/obf.jar` в папку игры `heroes/jars` под именем `obf.jar`.

> **Важно:** библиотека игры из папки `libs/` используется только для компиляции (`compileOnly`) и не упаковывается внутрь `obf.jar`.  
> Итоговый `obf.jar` содержит только классы из пакета `programs/*` (реализацию интерфейсов игры).
---
## Тесты

В проекте есть набор unit-тестов на **JUnit 5**, которые проверяют корректность всех **четырёх** требуемых алгоритмов и закрывают ключевые граничные случаи из ТЗ.

### Что покрыто тестами

- **GeneratePresetImpl (генерация армии)**
  - Возвращает пустую армию при некорректных входных данных (пустой список шаблонов, неположительный бюджет).
  - Никогда не превышает `maxPoints`, а поле `Army.points` **совпадает** с суммой стоимостей юнитов.
  - Соблюдает лимит **≤ 11 юнитов на каждый unitType**.
  - Расставляет юнитов на сетке **3×21**: координаты **в пределах** и **без коллизий** (уникальные клетки).
  - Генерирует юнитов **только из переданных типов** и **копирует статы из шаблонов**.
  - Корректно останавливается, когда **ничего не помещается в бюджет**, либо когда **поле заполнено** (максимум 63 клетки).

- **SimulateBattleImpl (симуляция боя)**
  - Мгновенно завершает бой, если у одной армии нет живых юнитов.
  - Корректно обрабатывает ситуации “нет цели” (`attack()` возвращает `null`) и особый случай, когда некоторые программы возвращают **self** (трактуется как “нет цели”).
  - Гарантирует, что юнит, который умер **до своего хода в текущем раунде**, **не ходит** (логика пересборки очереди работает).
  - Проверяет порядок ходов в раунде: ходят по **убыванию `baseAttack`**, с **чередованием сторон**.

- **SuitableForAttackUnitsFinderImpl (отбор доступных целей)**
  - Проверяет логику “прикрыт/не прикрыт” для 3 колонок с учётом `isLeftArmyTarget` (разная ориентация сторон).
  - Граничные случаи: пустые колонки, мёртвые юниты не блокируют, отсутствие подходящих целей (возвращается пустой список и печатается ожидаемое сообщение).

- **UnitTargetPathFinderImpl (поиск кратчайшего пути)**
  - Проверяет, что путь находится “в обход” препятствий (сценарий со “стеной”).
  - Убеждается, что путь не проходит через занятые клетки.


> Примечание: в тестах используются простые stub-реализации `Program`, чтобы сделать бой детерминированным и проверить правила (очерёдность, тупики, ранняя смерть юнита) без зависимости от внутренней логики встроенных игровых программ.

