# Heroes Student Task

# Description

тот репозиторий содержит мою реализацию требуемых алгоритмов для проекта **Heroes** (модуль `heroes_task`).  
Игра загружает данный модуль как JAR-файл и использует его для:

- генерации пресета армии противника,
- симуляции пошагового боя,
- отбора целей, доступных для атаки (для ближнего боя),
- поиска кратчайшего пути на игровом поле между юнитами.

---

## Структура проекта
    src/
     programs/
      GeneratePresetImpl.java
      SimulateBattleImpl.java
      SuitableForAttackUnitsFinderImpl.java
      UnitTargetPathFinderImpl.java

Собранный артефакт (JAR) также добавлен в репозиторий — его можно подложить в папку игры `heroes/jars` под именем `obf.jar`.

## Реализованные алгоритмы

### 1) Генерация армии противника — `GeneratePresetImpl.generate(...)`

**Цель:** сформировать армию компьютера при ограничениях:
- суммарная стоимость ≤ `maxPoints`,
- не более 11 юнитов каждого типа,
- максимальная эффективность: в первую очередь по **атака/стоимость**, во вторую — по **здоровье/стоимость**.

**Подход:**
- **Multi-start greedy** (мульти-старт жадный алгоритм): на каждом шаге добавляется следующий лучший юнит по взвешенному скору:
    - основное: `baseAttack / cost`,
    - вторичное: `health / cost`,
    - небольшой “diversity”-фактор, чтобы не перекосить состав в один тип слишком рано,
    - минимальный “jitter” для вариативности между перезапусками (при сохранении общей логики).
- После жадной фазы выполняется **fill-pass**: добор армии самыми дешёвыми подходящими юнитами (с тай-брейком по эффективности), чтобы лучше использовать оставшиеся очки.
- Координаты назначаются безопасно внутри сетки **3×21** (`x ∈ [0..2]`, `y ∈ [0..20]`) и проверяются на занятость за **O(1)** через boolean-матрицу.

**Сложность:**
Обозначим:
- `m` — число типов юнитов (сейчас 4),
- `n` — максимальное число юнитов в армии (ограничено лимитами и площадью 3×21).

На один перезапуск:
- выбор следующего юнита: перебор типов/шаблонов → `O(m)` на одного добавленного юнита,
- добавлений максимум `n` → `O(m·n)`,
- проверка клетки на занятость через boolean-сетку → **O(1)** (fallback-сканирование — константа, ≤ 63 клеток).

Число перезапусков `R` фиксированное (например, 20), поэтому:
- итог: **O(R·m·n) = O(m·n)** (так как `R` — константа).

**Улучшение относительно базовой реализации:**
В базовой реализации проверка занятости клетки выполняется через `stream().anyMatch(...)` по растущему списку уже размещённых юнитов.  
Это даёт проверку **O(i)** на i-й вставке и суммарно приводит к **O(n²)** в худшем случае.

В текущей реализации используется boolean-матрица занятости фиксированного размера (3×21), поэтому проверка клетки — **O(1)**, а весь метод работает за **O(m·n)**.

---

### 2) Симуляция боя — `SimulateBattleImpl.simulate(...)`

**Цель:** корректно смоделировать бой по правилам:
- бой идёт по раундам,
- внутри раунда порядок ходов — сначала более сильные по `baseAttack`,
- ходы чередуются между армией игрока и компьютера,
- если юнит погиб до своего хода в текущем раунде — его нужно исключить сразу и пересчитать очереди,
- после каждой атаки вызвать `printBattleLog.printBattleLog(attacker, target)`,
- бой заканчивается только, когда в одной из армий не остаётся живых юнитов, способных сделать ход.

**Подход:**
- Используется множество `actedThisRound`, чтобы каждый живой юнит ходил не более одного раза за раунд.
- Очереди строятся через **attack buckets**:
    - `TreeMap<baseAttack, Deque<Unit>>` в порядке убывания атаки.
    - Это позволяет не сортировать список заново при каждом пересчёте.
- При смерти цели, которая ещё не ходила в текущем раунде, включается `needRebuild=true`, и очереди пересчитываются немедленно (через пересборку бакетов).
- После каждого раунда печатается:
    - `Round N is over!` + количество живых юнитов у каждой армии (как отладочный вывод).

**Сложность:**
Пусть `N` — общее число живых юнитов в обеих армиях.
- Сборка бакетов: вставка каждого юнита → **O(N log K)**, где `K` — число уникальных значений атаки (обычно небольшое),
- Извлечение юнитов: каждый извлекается максимум один раз между пересчётами → **O(N)** на пересборку.
  Пересборки происходят при “важных” смертях (юнит умер до хода), что на практике ограничено.

Итого по раунду поведение близко к **O(N log N)** и хорошо держит нагрузку.

---

### 3) Отбор целей для атаки — `SuitableForAttackUnitsFinderImpl.getSuitableUnits(...)`

**Цель:** вернуть только те вражеские юниты, которые доступны для атаки (не “прикрыты” соседней колонкой):
- при атаке правой армии (армия игрока) цель недоступна, если закрыта справа (в соседней клетке/колонке по y стоит живой юнит той же армии),
- при атаке левой армии (армия компьютера) — аналогично, только блокировка слева.

Вход `unitsByRow` содержит 3 колонки (фиксировано), в каждой — список юнитов по y.

**Подход:**
- Для фронтальной и средней колонок строятся `BitSet` маски занятых y (только живые юниты).
- Юнит:
    - в передней колонке → всегда доступен,
    - в средней → доступен, если в передней нет живого с тем же y,
    - в задней → доступен, если в средней нет живого с тем же y.

**Сложность:**
Пусть `N` — число юнитов в трёх списках:
- построение BitSet + фильтрация — **O(N)**.
  Так как колонок всегда 3, фактически это линейная сложность по числу юнитов.

---

### 4) Поиск кратчайшего пути — `UnitTargetPathFinderImpl.getTargetPath(...)`

**Цель:** найти кратчайший путь от атакующего к цели на сетке:
- `WIDTH = 27`, `HEIGHT = 21`,
- движение разрешено в 8 направлений (включая диагонали),
- живые юниты (кроме атакующего и цели) считаются препятствиями,
- результат: список `Edge` (координаты пути), включающий старт и цель, либо пустой список, если пути нет.

**Подход: двунаправленный BFS (Bidirectional BFS)**
- BFS запускается одновременно от атакующего и от цели.
- Хранятся две матрицы посещений и два массива предков (`prevS` и `prevT`) для восстановления пути.
- Поиск останавливается при встрече фронтов.
- Фиксированный порядок направлений делает путь детерминированным (удобно для стабильного поведения и тестов).

**Сложность:**
На поле `V = WIDTH · HEIGHT` клеток.
- Каждая клетка посещается максимум по одному разу с каждой стороны → **O(V)**,
- проверка 8 соседей — константа.
  Итого:
- **O(WIDTH · HEIGHT)** по времени и памяти.

**Ускорение относительно обычного BFS:**
Bidirectional BFS на практике обходит меньше клеток, чем односторонний BFS, так как фронты растут навстречу друг другу.

---

## Как собрать JAR

Сборка в IntelliJ IDEA:

1. `File → Project Structure → Artifacts`
2. `+ → JAR → From modules with dependencies`
3. `Build → Build Artifacts → Build`

После сборки JAR появится примерно тут:

To DO::: ДОПИСАТЬ!!
