# Heroes Student Task

# Description

тот репозиторий содержит мою реализацию требуемых алгоритмов для проекта **Heroes** (модуль `heroes_task`).  
Игра загружает данный модуль как JAR-файл и использует его для:

- генерации пресета армии противника,
- симуляции пошагового боя,
- отбора целей, доступных для атаки (для ближнего боя),
- поиска кратчайшего пути на игровом поле между юнитами.

---

## Структура проекта
    src/
     programs/
      GeneratePresetImpl.java
      SimulateBattleImpl.java
      SuitableForAttackUnitsFinderImpl.java
      UnitTargetPathFinderImpl.java

Собранный артефакт (JAR) также добавлен в репозиторий — его можно подложить в папку игры `heroes/jars` под именем `obf.jar`.

## Реализованные алгоритмы

### 1) Генерация армии противника — `GeneratePresetImpl.generate(...)`

**Цель:** сформировать армию компьютера при ограничениях:
- суммарная стоимость ≤ `maxPoints`,
- не более 11 юнитов каждого типа,
- максимальная эффективность: в первую очередь по **атака/стоимость**, во вторую — по **здоровье/стоимость**.

**Подход:**
- **Multi-start greedy** (мульти-старт жадный алгоритм): выполняется фиксированное число перезапусков (например, 20), в каждом перезапуске армия собирается жадно.
- На каждом шаге добавляется следующий лучший юнит по **строгому приоритету задания**:
  - основное: `baseAttack / cost`,
  - вторичное: `health / cost`,
  - далее — детерминированные тай-брейки (например, по `baseAttack`, `health`, `cost`, `unitType`),
  - небольшой рандом используется **только** если все критерии полностью равны (для вариативности между перезапусками без нарушения приоритетов).
- После завершения каждого перезапуска выбирается лучший кандидат по суммарному скору, согласованному с тем же порядком предпочтений (attack-per-cost сначала, затем health-per-cost).
- Координаты назначаются безопасно внутри сетки **3×21** (`x ∈ [0..2]`, `y ∈ [0..20]`) и проверяются на занятость за **O(1)** через boolean-матрицу.

**Сложность:**
Обозначим:
- `m` — число типов юнитов (сейчас 4),
- `n` — максимальное число юнитов в армии (ограничено лимитами и площадью 3×21).

На один перезапуск:
- выбор следующего юнита: перебор типов/шаблонов → `O(m)` на одного добавленного юнита,
- добавлений максимум `n` → `O(m·n)`,
- проверка клетки на занятость через boolean-сетку → **O(1)** (fallback-сканирование — константа, ≤ 63 клеток).

Число перезапусков `R` фиксированное (например, 20), поэтому:
- итог: **O(R·m·n) = O(m·n)** (так как `R` — константа).

**Улучшение относительно базовой реализации:**
В базовой реализации проверка занятости клетки выполняется через `stream().anyMatch(...)` по растущему списку уже размещённых юнитов.  
Это даёт проверку **O(i)** на i-й вставке и суммарно приводит к **O(n²)** в худшем случае.

В текущей реализации используется boolean-матрица занятости фиксированного размера (3×21), поэтому проверка клетки — **O(1)**, а весь метод работает за **O(m·n)**.

---

### 2) Симуляция боя — `SimulateBattleImpl.simulate(...)`

**Цель:** корректно смоделировать бой по правилам:
- бой идёт по раундам,
- внутри раунда порядок ходов — сначала более сильные по `baseAttack`,
- ходы чередуются между армией игрока и компьютера,
- если юнит погиб до своего хода в текущем раунде — его нужно исключить сразу и пересчитать очереди,
- после каждой атаки вызвать `printBattleLog.printBattleLog(attacker, target)` (если `printBattleLog` не был заинжекчен (null), используется безопасный fallback-логгер в stdout, чтобы избежать `NullPointerException`),
- бой заканчивается только, когда в одной из армий не остаётся живых юнитов, способных сделать ход.

**Подход:**
- Используется множество `actedThisRound` (identity-based), чтобы каждый живой юнит ходил не более одного раза за раунд.
- На начало каждого раунда строятся две очереди ходов `PriorityQueue<Unit>` (max-heap по `baseAttack`):
  - в очередь попадают только живые юниты, которые ещё не ходили в текущем раунде.
- Ходы чередуются: сначала игрок (если есть юнит), затем компьютер (если есть юнит).
  Если у одной стороны очередь опустела — другая продолжает ходить.
- После каждого вызова `unit.getProgram().attack()` всегда вызывается `printBattleLog.printBattleLog(attacker, target)`.
  Если `attack()` вернул атакующего юнита (self), это трактуется как `null` (нет цели).
- Если цель умерла **до своего хода** в текущем раунде, пересобираются **обе очереди** ходов (игрока и компьютера), чтобы корректно восстановить порядок оставшихся ходов в раунде.
  (принадлежность определяется через identity-set `playerSide`).
- После каждого раунда печатается:
  - пустая строка,
  - `Round N is over!`,
  - количество живых юнитов у каждой армии,
  - пустая строка.

- **Завершение боя:**
  Бой завершается, если одна из армий осталась без живых юнитов, либо если за полный раунд одна из сторон
  не смогла выполнить ни одной осмысленной атаки (все `attack()` возвращали `null` / self → `null`).
  Это соответствует формулировке задания про “юнитов, способных сделать ход” и закрывает сценарии тупика.


**Сложность:**
Пусть `N` — общее число живых юнитов в обеих армиях в начале раунда.
- Построение очереди ходов для одной армии: **O(k log k)**, где `k` — число живых юнитов этой армии, ещё не ходивших в раунде.
- Каждый `poll()` из `PriorityQueue`: **O(log k)** на ход.
- Пересборка очереди происходит только при “важной” смерти: когда юнит умер до своего хода в текущем раунде.
  Причём пересобирается только очередь **одной** стороны (а не обе сразу), что снижает накладные расходы.

В сумме один раунд работает эффективно для ожидаемых размеров армий; асимптотически поведение сопоставимо с **O(N log N)**
с небольшим числом пересборок в реальных сценариях.

---

### 3) Отбор целей для атаки — `SuitableForAttackUnitsFinderImpl.getSuitableUnits(...)`

**Цель:** вернуть только те вражеские юниты, которые доступны для атаки (не “прикрыты” соседней колонкой):
- при атаке правой армии (армия игрока) цель недоступна, если закрыта справа (в соседней клетке/колонке по y стоит живой юнит той же армии),
- при атаке левой армии (армия компьютера) — аналогично, только блокировка слева.

Вход `unitsByRow` содержит 3 колонки (фиксировано), в каждой — список юнитов по y.

Важно: блокировка учитывает только соседнюю колонку (immediate neighbor), а не “любого юнита впереди”.

**Подход:**
- Для фронтальной и средней колонок строятся `BitSet` маски занятых y (только живые юниты).
- Юнит:
    - в передней колонке → всегда доступен,
    - в средней → доступен, если в передней нет живого с тем же y,
    - в задней → доступен, если в средней нет живого с тем же y.


**Сложность:**
Пусть `N` — число юнитов в трёх списках:
- построение BitSet + фильтрация — **O(N)**.
  Так как колонок всегда 3, фактически это линейная сложность по числу юнитов.
- 
- Если `unitsByRow == null` или список не содержит ровно 3 колонки, либо подходящих целей нет — возвращается пустой список и печатается `Unit can not find target for attack!`.

---

### 4) Поиск кратчайшего пути — `UnitTargetPathFinderImpl.getTargetPath(...)`

**Цель:** найти кратчайший путь от атакующего к цели на сетке:
- `WIDTH = 27`, `HEIGHT = 21`,
- движение разрешено в 8 направлений (включая диагонали),
- живые юниты (кроме атакующего и цели) считаются препятствиями,
- результат: список `Edge` (координаты пути), включающий старт и цель, либо пустой список, если пути нет.
- Диагональные ходы разрешены без дополнительных проверок “corner-cutting”.

**Подход: двунаправленный BFS (Bidirectional BFS)**
- BFS запускается одновременно от атакующего и от цели.
- Хранятся две матрицы посещений и два массива предков (`prevS` и `prevT`) для восстановления пути.
- Поиск останавливается при встрече фронтов.
- Фиксированный порядок направлений делает путь детерминированным (удобно для стабильного поведения и тестов).

**Сложность:**
На поле `V = WIDTH · HEIGHT` клеток.
- Каждая клетка посещается максимум по одному разу с каждой стороны → **O(V)**,
- проверка 8 соседей — константа.
  Итого:
- **O(WIDTH · HEIGHT)** по времени и памяти.

**Ускорение относительно обычного BFS:**
Bidirectional BFS на практике обходит меньше клеток, чем односторонний BFS, так как фронты растут навстречу друг другу.

---

## Сводная таблица сложности алгоритмов

| Компонент | Алгоритм | Сложность | Примечания |
|:---|:---|:---:|:---|
| **GeneratePresetImpl**<br>`generate(...)` | **Multi-start greedy**<br>(~20 перезапусков)<br>+ приоритет: `atk/cost` | **T:** `O(m·n)`<br>**M:** `O(1)`<br>*(const grid)* | Нет fill-pass.<br>Проверка занятости: `O(1)` (boolean grid 3×21).<br>Выбор лучшего по `score`. |
| **SimulateBattleImpl**<br>`simulate(...)` | **PriorityQueue** (max-heap)<br>+ Set `actedThisRound`<br>+ Раунды | **T:** `O(N log N)`<br>**M:** `O(N)` | Пересборка **обеих** очередей, если юнит умер до своего хода.<br>Завершение при тупике (нет атак). |
| **SuitableForAttack...**<br>`getSuitableUnits(...)` | **BitSet маски** по Y<br>+ Линейная фильтрация | **T:** `O(N)`<br>**M:** `O(H)`<br>*(H=21)* | Блокировка только **соседней** колонкой (immediate neighbor).<br>3 фиксированных ряда. |
| **UnitTargetPathFinder...**<br>`getTargetPath(...)` | **Bidirectional BFS**<br>Сетка 27×21<br>8 направлений | **T:** `O(W·H)`<br>**M:** `O(W·H)`<br>*(~567)* | Препятствия: все живые (кроме start/target).<br>Порядок направлений фиксирован (детерминизм). |

---
## Как собрать JAR

### Вариант 1. Сборка в IntelliJ IDEA:

1. `File → Project Structure → Artifacts`
2. `+ → JAR → From modules with dependencies`
3. `Build → Build Artifacts → Build`

Далее полученный артефакт можно подложить в папку jars проекта Heroes.

### Вариант 2: Gradle (рекомендуется)

Сборка `obf.jar` одной командой из корня проекта:

    bash ./gradlew clean jar

Результат появится здесь:

    build/libs/obf.jar`

Скопируйте `build/libs/obf.jar` в папку игры `heroes/jars` под именем `obf.jar`.

> **Важно:** библиотека игры из папки `libs/` используется только для компиляции (`compileOnly`) и не упаковывается внутрь `obf.jar`.  
> Итоговый `obf.jar` содержит только классы из пакета `programs/*` (реализацию интерфейсов игры).
---
## Тесты

В проекте есть набор unit-тестов на **JUnit 5**, которые проверяют корректность всех **четырёх** требуемых алгоритмов и закрывают ключевые граничные случаи из ТЗ.

### Что покрыто тестами

- **GeneratePresetImpl (генерация армии)**
  - Возвращает пустую армию при некорректных входных данных (пустой список шаблонов, неположительный бюджет).
  - Никогда не превышает `maxPoints`, а поле `Army.points` **совпадает** с суммой стоимостей юнитов.
  - Соблюдает лимит **≤ 11 юнитов на каждый unitType**.
  - Расставляет юнитов на сетке **3×21**: координаты **в пределах** и **без коллизий** (уникальные клетки).
  - Генерирует юнитов **только из переданных типов** и **копирует статы из шаблонов**.
  - Корректно останавливается, когда **ничего не помещается в бюджет**, либо когда **поле заполнено** (максимум 63 клетки).

- **SimulateBattleImpl (симуляция боя)**
  - Мгновенно завершает бой, если у одной армии нет живых юнитов.
  - Корректно обрабатывает ситуации “нет цели” (`attack()` возвращает `null`) и особый случай, когда некоторые программы возвращают **self** (трактуется как “нет цели”).
  - Гарантирует, что юнит, который умер **до своего хода в текущем раунде**, **не ходит** (логика пересборки очереди работает).
  - Проверяет порядок ходов в раунде: ходят по **убыванию `baseAttack`**, с **чередованием сторон**.

- **SuitableForAttackUnitsFinderImpl (отбор доступных целей)**
  - Проверяет логику “прикрыт/не прикрыт” для 3 колонок с учётом `isLeftArmyTarget` (разная ориентация сторон).
  - Граничные случаи: пустые колонки, мёртвые юниты не блокируют, отсутствие подходящих целей (возвращается пустой список и печатается ожидаемое сообщение).

- **UnitTargetPathFinderImpl (поиск кратчайшего пути)**
  - Проверяет, что путь находится “в обход” препятствий (сценарий со “стеной”).
  - Убеждается, что путь не проходит через занятые клетки.


> Примечание: в тестах используются простые stub-реализации `Program`, чтобы сделать бой детерминированным и проверить правила (очерёдность, тупики, ранняя смерть юнита) без зависимости от внутренней логики встроенных игровых программ.

